'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var react = require('react');
var warning = _interopDefault(require('tiny-warning'));
var raf = _interopDefault(require('raf'));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var noop = function noop() {};
function getElementHeight(el) {
  if (!(el === null || el === void 0 ? void 0 : el.current)) {
     warning(true, "useCollapse was not able to find a ref to the collapse element via `getCollapseProps`. Ensure that the element exposes its `ref` prop. If it exposes the ref prop under a different name (like `innerRef`), use the `refKey` property to change it. Example:\n\n{...getCollapseProps({refKey: 'innerRef'})}") ;
    return 'auto';
  }

  return el.current.scrollHeight;
} // Helper function for render props. Sets a function to be called, plus any additional functions passed in

var callAll = function callAll() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return fns.forEach(function (fn) {
      return fn && fn.apply(void 0, args);
    });
  };
}; // https://github.com/mui-org/material-ui/blob/da362266f7c137bf671d7e8c44c84ad5cfc0e9e2/packages/material-ui/src/styles/transitions.js#L89-L98

function getAutoHeightDuration(height) {
  if (!height || typeof height === 'string') {
    return 0;
  }

  var constant = height / 36; // https://www.wolframalpha.com/input/?i=(4+%2B+15+*+(x+%2F+36+)+**+0.25+%2B+(x+%2F+36)+%2F+5)+*+10

  return Math.round((4 + 15 * Math.pow(constant, 0.25) + constant / 5) * 10);
}
function assignRef(ref, value) {
  if (ref == null) return;

  if (typeof ref === 'function') {
    ref(value);
  } else {
    try {
      ref.current = value;
    } catch (error) {
      throw new Error("Cannot assign value \"" + value + "\" to ref \"" + ref + "\"");
    }
  }
}
/**
 * Passes or assigns a value to multiple refs (typically a DOM node). Useful for
 * dealing with components that need an explicit ref for DOM calculations but
 * also forwards refs assigned by an app.
 *
 * @param refs Refs to fork
 */

function mergeRefs() {
  for (var _len3 = arguments.length, refs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    refs[_key3] = arguments[_key3];
  }

  if (refs.every(function (ref) {
    return ref == null;
  })) {
    return null;
  }

  return function (node) {
    refs.forEach(function (ref) {
      assignRef(ref, node);
    });
  };
}
function useControlledState(isExpanded, defaultExpanded) {
  var _useState = react.useState(defaultExpanded || false),
      stateExpanded = _useState[0],
      setStateExpanded = _useState[1];

  var initiallyControlled = react.useRef(isExpanded != null);
  var expanded = initiallyControlled.current ? isExpanded : stateExpanded;
  var setExpanded = react.useCallback(function (n) {
    if (!initiallyControlled.current) {
      setStateExpanded(n);
    }
  }, []);
  react.useEffect(function () {
     warning(!(initiallyControlled.current && isExpanded == null), 'useCollapse is changing from controlled to uncontrolled. useCollapse should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop.') ;
     warning(!(!initiallyControlled.current && isExpanded != null), 'useCollapse is changing from uncontrolled to controlled. useCollapse should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop.') ;
  }, [isExpanded]);
  return [expanded, setExpanded];
}
function useEffectAfterMount(cb, dependencies) {
  var justMounted = react.useRef(true); // eslint-disable-next-line consistent-return

  react.useEffect(function () {
    if (!justMounted.current) {
      return cb();
    }

    justMounted.current = false; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, dependencies);
}
/**
 * Taken from Reach
 * https://github.com/reach/reach-ui/blob/d2b88c50caf52f473a7d20a4493e39e3c5e95b7b/packages/auto-id
 *
 * Autogenerate IDs to facilitate WAI-ARIA and server rendering.
 *
 * Note: The returned ID will initially be `null` and will update after a
 * component mounts. Users may need to supply their own ID if they need
 * consistent values for SSR.
 *
 * @see Docs https://reach.tech/auto-id
 */

var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react.useEffect : react.useLayoutEffect;
var serverHandoffComplete = false;
var id = 0;

var genId = function genId() {
  return ++id;
};

function useUniqueId(idFromProps) {
  /*
   * If this instance isn't part of the initial render, we don't have to do the
   * double render/patch-up dance. We can just generate the ID and return it.
   */
  var initialId = idFromProps || (serverHandoffComplete ? genId() : null);

  var _useState2 = react.useState(initialId),
      id = _useState2[0],
      setId = _useState2[1];

  useIsomorphicLayoutEffect(function () {
    if (id === null) {
      /*
       * Patch the ID after render. We do this in `useLayoutEffect` to avoid any
       * rendering flicker, though it'll make the first render slower (unlikely
       * to matter, but you're welcome to measure your app and let us know if
       * it's a problem).
       */
      setId(genId());
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, []);
  react.useEffect(function () {
    if (serverHandoffComplete === false) {
      /*
       * Flag all future uses of `useId` to skip the update dance. This is in
       * `useEffect` because it goes after `useLayoutEffect`, ensuring we don't
       * accidentally bail out of the patch-up dance prematurely.
       */
      serverHandoffComplete = true;
    }
  }, []);
  return id != null ? String(id) : undefined;
}
function usePaddingWarning(element) {
  // @ts-ignore
  var warn = function warn(el) {};

  {
    warn = function warn(el) {
      if (!(el === null || el === void 0 ? void 0 : el.current)) {
        return;
      }

      var _window$getComputedSt = window.getComputedStyle(el.current),
          paddingTop = _window$getComputedSt.paddingTop,
          paddingBottom = _window$getComputedSt.paddingBottom;

      var hasPadding = paddingTop && paddingTop !== '0px' || paddingBottom && paddingBottom !== '0px';
       warning(!hasPadding, 'react-collapsed: Padding applied to the collapse element will cause the animation to break and not perform as expected. To fix, apply equivalent padding to the direct descendent of the collapse element.') ;
    };
  }

  react.useEffect(function () {
    warn(element);
  }, [element]);
}

var easeInOut = 'cubic-bezier(0.4, 0, 0.2, 1)';
function useCollapse(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      duration = _ref.duration,
      _ref$easing = _ref.easing,
      easing = _ref$easing === void 0 ? easeInOut : _ref$easing,
      _ref$collapseStyles = _ref.collapseStyles,
      collapseStyles = _ref$collapseStyles === void 0 ? {} : _ref$collapseStyles,
      _ref$expandStyles = _ref.expandStyles,
      expandStyles = _ref$expandStyles === void 0 ? {} : _ref$expandStyles,
      _ref$onExpandStart = _ref.onExpandStart,
      onExpandStart = _ref$onExpandStart === void 0 ? noop : _ref$onExpandStart,
      _ref$onExpandEnd = _ref.onExpandEnd,
      onExpandEnd = _ref$onExpandEnd === void 0 ? noop : _ref$onExpandEnd,
      _ref$onCollapseStart = _ref.onCollapseStart,
      onCollapseStart = _ref$onCollapseStart === void 0 ? noop : _ref$onCollapseStart,
      _ref$onCollapseEnd = _ref.onCollapseEnd,
      onCollapseEnd = _ref$onCollapseEnd === void 0 ? noop : _ref$onCollapseEnd,
      configIsExpanded = _ref.isExpanded,
      _ref$defaultExpanded = _ref.defaultExpanded,
      defaultExpanded = _ref$defaultExpanded === void 0 ? false : _ref$defaultExpanded,
      initialConfig = _objectWithoutPropertiesLoose(_ref, ["duration", "easing", "collapseStyles", "expandStyles", "onExpandStart", "onExpandEnd", "onCollapseStart", "onCollapseEnd", "isExpanded", "defaultExpanded"]);

  var _useControlledState = useControlledState(configIsExpanded, defaultExpanded),
      isExpanded = _useControlledState[0],
      setExpanded = _useControlledState[1];

  var uniqueId = useUniqueId();
  var el = react.useRef(null);
  usePaddingWarning(el);
  var collapsedHeight = (initialConfig.collapsedHeight || 0) + "px";
  var collapsedStyles = {
    display: collapsedHeight === '0px' ? 'none' : 'block',
    height: collapsedHeight,
    overflow: 'hidden'
  };

  var _useState = react.useState(isExpanded ? {} : collapsedStyles),
      styles = _useState[0],
      setStyles = _useState[1];

  var mergeStyles = react.useCallback(function (newStyles) {
    setStyles(function (oldStyles) {
      return _extends({}, oldStyles, newStyles);
    });
  }, []);

  function getTransitionStyles(height) {
    var _duration = duration || getAutoHeightDuration(height);

    return {
      transition: "height " + _duration + "ms " + easing
    };
  }

  useEffectAfterMount(function () {
    if (isExpanded) {
      raf(function () {
        onExpandStart();
        mergeStyles(_extends({}, expandStyles, {
          willChange: 'height',
          display: 'block',
          overflow: 'hidden'
        }));
        raf(function () {
          var height = getElementHeight(el);
          mergeStyles(_extends({}, getTransitionStyles(height), {
            height: height
          }));
        });
      });
    } else {
      raf(function () {
        onCollapseStart();
        var height = getElementHeight(el);
        mergeStyles(_extends({}, collapseStyles, getTransitionStyles(height), {
          willChange: 'height',
          height: height
        }));
        raf(function () {
          mergeStyles({
            height: collapsedHeight,
            overflow: 'hidden'
          });
        });
      });
    }
  }, [isExpanded]);

  var handleTransitionEnd = function handleTransitionEnd(e) {
    // Sometimes onTransitionEnd is triggered by another transition,
    // such as a nested collapse panel transitioning. But we only
    // want to handle this if this component's element is transitioning
    if (e.target !== el.current || e.propertyName !== 'height') {
      return;
    } // The height comparisons below are a final check before
    // completing the transition
    // Sometimes this callback is run even though we've already begun
    // transitioning the other direction
    // The conditions give us the opportunity to bail out,
    // which will prevent the collapsed content from flashing on the screen


    if (isExpanded) {
      var height = getElementHeight(el); // If the height at the end of the transition
      // matches the height we're animating to,

      if (height === styles.height) {
        setStyles({});
      } else {
        // If the heights don't match, this could be due the height
        // of the content changing mid-transition
        mergeStyles({
          height: height
        });
      }

      onExpandEnd(); // If the height we should be animating to matches the collapsed height,
      // it's safe to apply the collapsed overrides
    } else if (styles.height === collapsedHeight) {
      setStyles(collapsedStyles);
      onCollapseEnd();
    }
  };

  function getToggleProps(_temp2) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2,
        _ref2$disabled = _ref2.disabled,
        disabled = _ref2$disabled === void 0 ? false : _ref2$disabled,
        _ref2$onClick = _ref2.onClick,
        onClick = _ref2$onClick === void 0 ? noop : _ref2$onClick,
        rest = _objectWithoutPropertiesLoose(_ref2, ["disabled", "onClick"]);

    return _extends({
      type: 'button',
      role: 'button',
      id: "react-collapsed-toggle-" + uniqueId,
      'aria-controls': "react-collapsed-panel-" + uniqueId,
      'aria-expanded': isExpanded,
      tabIndex: 0,
      disabled: disabled
    }, rest, {
      onClick: disabled ? noop : callAll(onClick, function () {
        return setExpanded(function (n) {
          return !n;
        });
      })
    });
  }

  function getCollapseProps(_temp3) {
    var _extends2;

    var _ref3 = _temp3 === void 0 ? {} : _temp3,
        _ref3$style = _ref3.style,
        style = _ref3$style === void 0 ? {} : _ref3$style,
        _ref3$onTransitionEnd = _ref3.onTransitionEnd,
        onTransitionEnd = _ref3$onTransitionEnd === void 0 ? noop : _ref3$onTransitionEnd,
        _ref3$refKey = _ref3.refKey,
        refKey = _ref3$refKey === void 0 ? 'ref' : _ref3$refKey,
        rest = _objectWithoutPropertiesLoose(_ref3, ["style", "onTransitionEnd", "refKey"]);

    var theirRef = rest[refKey];
    return _extends({
      id: "react-collapsed-panel-" + uniqueId,
      'aria-hidden': !isExpanded
    }, rest, (_extends2 = {}, _extends2[refKey] = mergeRefs(el, theirRef), _extends2.onTransitionEnd = callAll(handleTransitionEnd, onTransitionEnd), _extends2.style = _extends({
      boxSizing: 'border-box'
    }, style, styles), _extends2));
  }

  return {
    getToggleProps: getToggleProps,
    getCollapseProps: getCollapseProps,
    isExpanded: isExpanded,
    setExpanded: setExpanded
  };
}

exports.default = useCollapse;
//# sourceMappingURL=react-collapsed.cjs.development.js.map
