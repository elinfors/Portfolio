{"version":3,"file":"react-collapsed.cjs.production.min.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["import {\n  RefObject,\n  useState,\n  useRef,\n  useEffect,\n  useCallback,\n  useLayoutEffect,\n} from 'react';\nimport warning from 'tiny-warning';\nimport { AssignableRef } from './types';\n\ntype AnyFunction = (...args: any[]) => unknown;\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop = (): void => {};\n\nexport function getElementHeight(\n  el: RefObject<HTMLElement> | { current?: { scrollHeight: number } }\n): string | number {\n  if (!el?.current) {\n    warning(\n      true,\n      `useCollapse was not able to find a ref to the collapse element via \\`getCollapseProps\\`. Ensure that the element exposes its \\`ref\\` prop. If it exposes the ref prop under a different name (like \\`innerRef\\`), use the \\`refKey\\` property to change it. Example:\n\n{...getCollapseProps({refKey: 'innerRef'})}`\n    );\n    return 'auto';\n  }\n  return el.current.scrollHeight;\n}\n\n// Helper function for render props. Sets a function to be called, plus any additional functions passed in\nexport const callAll = (...fns: AnyFunction[]) => (...args: any[]): void =>\n  fns.forEach((fn) => fn && fn(...args));\n\n// https://github.com/mui-org/material-ui/blob/da362266f7c137bf671d7e8c44c84ad5cfc0e9e2/packages/material-ui/src/styles/transitions.js#L89-L98\nexport function getAutoHeightDuration(height: number | string): number {\n  if (!height || typeof height === 'string') {\n    return 0;\n  }\n\n  const constant = height / 36;\n\n  // https://www.wolframalpha.com/input/?i=(4+%2B+15+*+(x+%2F+36+)+**+0.25+%2B+(x+%2F+36)+%2F+5)+*+10\n  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);\n}\n\nexport function assignRef<RefValueType = any>(\n  ref: AssignableRef<RefValueType> | null | undefined,\n  value: any\n) {\n  if (ref == null) return;\n  if (typeof ref === 'function') {\n    ref(value);\n  } else {\n    try {\n      ref.current = value;\n    } catch (error) {\n      throw new Error(`Cannot assign value \"${value}\" to ref \"${ref}\"`);\n    }\n  }\n}\n\n/**\n * Passes or assigns a value to multiple refs (typically a DOM node). Useful for\n * dealing with components that need an explicit ref for DOM calculations but\n * also forwards refs assigned by an app.\n *\n * @param refs Refs to fork\n */\nexport function mergeRefs<RefValueType = any>(\n  ...refs: (AssignableRef<RefValueType> | null | undefined)[]\n) {\n  if (refs.every((ref) => ref == null)) {\n    return null;\n  }\n  return (node: any) => {\n    refs.forEach((ref) => {\n      assignRef(ref, node);\n    });\n  };\n}\n\nexport function useControlledState(\n  isExpanded?: boolean,\n  defaultExpanded?: boolean\n): [boolean, React.Dispatch<React.SetStateAction<boolean>>] {\n  const [stateExpanded, setStateExpanded] = useState(defaultExpanded || false);\n  const initiallyControlled = useRef(isExpanded != null);\n  const expanded = initiallyControlled.current\n    ? (isExpanded as boolean)\n    : stateExpanded;\n  const setExpanded = useCallback((n) => {\n    if (!initiallyControlled.current) {\n      setStateExpanded(n);\n    }\n  }, []);\n\n  useEffect(() => {\n    warning(\n      !(initiallyControlled.current && isExpanded == null),\n      'useCollapse is changing from controlled to uncontrolled. useCollapse should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop.'\n    );\n    warning(\n      !(!initiallyControlled.current && isExpanded != null),\n      'useCollapse is changing from uncontrolled to controlled. useCollapse should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop.'\n    );\n  }, [isExpanded]);\n\n  return [expanded, setExpanded];\n}\n\nexport function useEffectAfterMount(\n  cb: () => void,\n  dependencies: unknown[]\n): void {\n  const justMounted = useRef(true);\n  // eslint-disable-next-line consistent-return\n  useEffect(() => {\n    if (!justMounted.current) {\n      return cb();\n    }\n    justMounted.current = false;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencies);\n}\n\n/**\n * Taken from Reach\n * https://github.com/reach/reach-ui/blob/d2b88c50caf52f473a7d20a4493e39e3c5e95b7b/packages/auto-id\n *\n * Autogenerate IDs to facilitate WAI-ARIA and server rendering.\n *\n * Note: The returned ID will initially be `null` and will update after a\n * component mounts. Users may need to supply their own ID if they need\n * consistent values for SSR.\n *\n * @see Docs https://reach.tech/auto-id\n */\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useEffect : useLayoutEffect;\nlet serverHandoffComplete = false;\nlet id = 0;\nconst genId = () => ++id;\nexport function useUniqueId(idFromProps?: string | null) {\n  /*\n   * If this instance isn't part of the initial render, we don't have to do the\n   * double render/patch-up dance. We can just generate the ID and return it.\n   */\n  const initialId = idFromProps || (serverHandoffComplete ? genId() : null);\n\n  const [id, setId] = useState(initialId);\n\n  useIsomorphicLayoutEffect(() => {\n    if (id === null) {\n      /*\n       * Patch the ID after render. We do this in `useLayoutEffect` to avoid any\n       * rendering flicker, though it'll make the first render slower (unlikely\n       * to matter, but you're welcome to measure your app and let us know if\n       * it's a problem).\n       */\n      setId(genId());\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    if (serverHandoffComplete === false) {\n      /*\n       * Flag all future uses of `useId` to skip the update dance. This is in\n       * `useEffect` because it goes after `useLayoutEffect`, ensuring we don't\n       * accidentally bail out of the patch-up dance prematurely.\n       */\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id != null ? String(id) : undefined;\n}\n\nexport function usePaddingWarning(element: RefObject<HTMLElement>): void {\n  // @ts-ignore\n  let warn = (el?: RefObject<HTMLElement>): void => {};\n\n  if (__DEV__) {\n    warn = (el) => {\n      if (!el?.current) {\n        return;\n      }\n      const { paddingTop, paddingBottom } = window.getComputedStyle(el.current);\n      const hasPadding =\n        (paddingTop && paddingTop !== '0px') ||\n        (paddingBottom && paddingBottom !== '0px');\n\n      warning(\n        !hasPadding,\n        'react-collapsed: Padding applied to the collapse element will cause the animation to break and not perform as expected. To fix, apply equivalent padding to the direct descendent of the collapse element.'\n      );\n    };\n  }\n\n  useEffect(() => {\n    warn(element);\n  }, [element]);\n}\n","import {\n  useState,\n  useRef,\n  useCallback,\n  TransitionEvent,\n  CSSProperties,\n} from 'react';\nimport {\n  noop,\n  callAll,\n  getElementHeight,\n  getAutoHeightDuration,\n  mergeRefs,\n  usePaddingWarning,\n  useUniqueId,\n  useEffectAfterMount,\n  useControlledState,\n} from './utils';\nimport {\n  UseCollapseInput,\n  UseCollapseOutput,\n  GetCollapsePropsOutput,\n  GetCollapsePropsInput,\n  GetTogglePropsOutput,\n  GetTogglePropsInput,\n} from './types';\nimport raf from 'raf';\n\nconst easeInOut = 'cubic-bezier(0.4, 0, 0.2, 1)';\n\nexport default function useCollapse({\n  duration,\n  easing = easeInOut,\n  collapseStyles = {},\n  expandStyles = {},\n  onExpandStart = noop,\n  onExpandEnd = noop,\n  onCollapseStart = noop,\n  onCollapseEnd = noop,\n  isExpanded: configIsExpanded,\n  defaultExpanded = false,\n  ...initialConfig\n}: UseCollapseInput = {}): UseCollapseOutput {\n  const [isExpanded, setExpanded] = useControlledState(\n    configIsExpanded,\n    defaultExpanded\n  );\n  const uniqueId = useUniqueId();\n  const el = useRef<HTMLElement | null>(null);\n  usePaddingWarning(el);\n  const collapsedHeight = `${initialConfig.collapsedHeight || 0}px`;\n  const collapsedStyles = {\n    display: collapsedHeight === '0px' ? 'none' : 'block',\n    height: collapsedHeight,\n    overflow: 'hidden',\n  };\n  const [styles, setStyles] = useState<CSSProperties>(\n    isExpanded ? {} : collapsedStyles\n  );\n  const mergeStyles = useCallback((newStyles: {}): void => {\n    setStyles((oldStyles) => ({ ...oldStyles, ...newStyles }));\n  }, []);\n\n  function getTransitionStyles(\n    height: number | string\n  ): { transition: string } {\n    const _duration = duration || getAutoHeightDuration(height);\n    return {\n      transition: `height ${_duration}ms ${easing}`,\n    };\n  }\n\n  useEffectAfterMount(() => {\n    if (isExpanded) {\n      raf(() => {\n        onExpandStart();\n        mergeStyles({\n          ...expandStyles,\n          willChange: 'height',\n          display: 'block',\n          overflow: 'hidden',\n        });\n        raf(() => {\n          const height = getElementHeight(el);\n          mergeStyles({\n            ...getTransitionStyles(height),\n            height,\n          });\n        });\n      });\n    } else {\n      raf(() => {\n        onCollapseStart();\n        const height = getElementHeight(el);\n        mergeStyles({\n          ...collapseStyles,\n          ...getTransitionStyles(height),\n          willChange: 'height',\n          height,\n        });\n        raf(() => {\n          mergeStyles({\n            height: collapsedHeight,\n            overflow: 'hidden',\n          });\n        });\n      });\n    }\n  }, [isExpanded]);\n\n  const handleTransitionEnd = (e: TransitionEvent): void => {\n    // Sometimes onTransitionEnd is triggered by another transition,\n    // such as a nested collapse panel transitioning. But we only\n    // want to handle this if this component's element is transitioning\n    if (e.target !== el.current || e.propertyName !== 'height') {\n      return;\n    }\n\n    // The height comparisons below are a final check before\n    // completing the transition\n    // Sometimes this callback is run even though we've already begun\n    // transitioning the other direction\n    // The conditions give us the opportunity to bail out,\n    // which will prevent the collapsed content from flashing on the screen\n    if (isExpanded) {\n      const height = getElementHeight(el);\n\n      // If the height at the end of the transition\n      // matches the height we're animating to,\n      if (height === styles.height) {\n        setStyles({});\n      } else {\n        // If the heights don't match, this could be due the height\n        // of the content changing mid-transition\n        mergeStyles({ height });\n      }\n\n      onExpandEnd();\n\n      // If the height we should be animating to matches the collapsed height,\n      // it's safe to apply the collapsed overrides\n    } else if (styles.height === collapsedHeight) {\n      setStyles(collapsedStyles);\n      onCollapseEnd();\n    }\n  };\n\n  function getToggleProps({\n    disabled = false,\n    onClick = noop,\n    ...rest\n  }: GetTogglePropsInput = {}): GetTogglePropsOutput {\n    return {\n      type: 'button',\n      role: 'button',\n      id: `react-collapsed-toggle-${uniqueId}`,\n      'aria-controls': `react-collapsed-panel-${uniqueId}`,\n      'aria-expanded': isExpanded,\n      tabIndex: 0,\n      disabled,\n      ...rest,\n      onClick: disabled ? noop : callAll(onClick, () => setExpanded((n) => !n)),\n    };\n  }\n\n  function getCollapseProps({\n    style = {},\n    onTransitionEnd = noop,\n    refKey = 'ref',\n    ...rest\n  }: GetCollapsePropsInput = {}): GetCollapsePropsOutput {\n    const theirRef: any = rest[refKey];\n    return {\n      id: `react-collapsed-panel-${uniqueId}`,\n      'aria-hidden': !isExpanded,\n      ...rest,\n      [refKey]: mergeRefs(el, theirRef),\n      onTransitionEnd: callAll(handleTransitionEnd, onTransitionEnd),\n      style: {\n        boxSizing: 'border-box',\n        // additional styles passed, e.g. getCollapseProps({style: {}})\n        ...style,\n        // style overrides from state\n        ...styles,\n      },\n    };\n  }\n\n  return {\n    getToggleProps,\n    getCollapseProps,\n    isExpanded,\n    setExpanded,\n  };\n}\n"],"names":["noop","getElementHeight","el","current","scrollHeight","callAll","fns","args","forEach","fn","assignRef","ref","value","error","Error","useIsomorphicLayoutEffect","window","useEffect","useLayoutEffect","serverHandoffComplete","id","genId","duration","easing","collapseStyles","expandStyles","onExpandStart","onExpandEnd","onCollapseStart","onCollapseEnd","configIsExpanded","isExpanded","defaultExpanded","initialConfig","useState","stateExpanded","setStateExpanded","initiallyControlled","useRef","expanded","setExpanded","useCallback","n","useControlledState","uniqueId","idFromProps","initialId","setId","String","undefined","useUniqueId","cb","dependencies","justMounted","collapsedHeight","collapsedStyles","display","height","overflow","styles","setStyles","mergeStyles","newStyles","oldStyles","getTransitionStyles","transition","constant","Math","round","getAutoHeightDuration","raf","willChange","handleTransitionEnd","e","target","propertyName","getToggleProps","disabled","onClick","rest","type","role","tabIndex","getCollapseProps","style","onTransitionEnd","refKey","refs","every","node","mergeRefs","boxSizing"],"mappings":"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"}